# -*- coding: utf-8 -*-
"""Simulação de caixa de mercado sem ser FIFO

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1npCynVg31MuyCq8M3OVkd9z7Ic0Va3Fj

#Métricas Globais (sem FIFO)
"""

!pip install simpy
import simpy
import numpy as np
from scipy.stats import expon, norm
import matplotlib.pyplot as plt  # Importando biblioteca para o gráfico

# Listas de horários de chegada e saída dos caixas
chegadas, saidas, desistencias = [], [], []
# Listas de horários de chegada e saída das filas
in_queue, in_system, tempos_de_atendimento = [], [], []  # Adicionando lista para tempos de atendimento
horarios_nas_filas, tamanho_da_fila = [], []

# Constantes para o tempo médio de chegada de clientes, atendimento e falha
MEDIA_DE_CHEGADA_DE_CLIENTES = 3
MEDIA_DO_TEMPO_DE_ATENDIMENTO = 3.0
DESVIO_PADRAO_DO_TEMPO_DE_ATENDIMENTO = 0.5
TEMPO_MAXIMO_DE_ESPERA = 1.5  # Tempo máximo que um cliente está disposto a esperar
TEMPO_DE_REPARO = 10  # Tempo necessário para reparar o caixa após uma falha
PROBABILIDADE_BASE_DE_FALHA = 0.05  # Probabilidade inicial de falha de um caixa
AUMENTO_PROBABILIDADE_POR_USO = 0.01  # Aumento da probabilidade de falha a cada uso

# Configuração de horários de pico
HORARIOS_DE_PICO = [(30, 50)]  # Intervalos de horário (em minutos)
FATOR_DE_PICO = 0.5  # Fator para reduzir o tempo médio entre chegadas (aumenta o fluxo)

# Contador de uso e falhas nos caixas
uso_dos_caixas = 0
falhas_no_sistema = 0

# Definindo a probabilidade de um cliente ser preferencial
PROBABILIDADE_DE_CLIENTE_PREFERENCIAL = 0.3

# Função para registrar o estado da fila
def salva_info_da_fila(env, caixa):
    horario_medicao = env.now
    tamanho_da_fila_agora = len(caixa.queue)
    horarios_nas_filas.append(horario_medicao)
    tamanho_da_fila.append(tamanho_da_fila_agora)
    return horario_medicao

# Distribuição do tempo de chegada dos clientes com consideração de horários de pico
def distribuicao_chegada_de_clientes(env):
    # Verifica se está em horário de pico
    em_pico = any(inicio <= env.now <= fim for inicio, fim in HORARIOS_DE_PICO)
    fator = FATOR_DE_PICO if em_pico else 1.0
    tempo_entre_chegadas = expon.rvs(scale=MEDIA_DE_CHEGADA_DE_CLIENTES * fator)
    return tempo_entre_chegadas

# Calcula o tempo total no sistema (do cliente na fila até sair do caixa)
def calcula_tempo_no_sistema(env, horario_chegada):
    horario_saida = env.now
    saidas.append(horario_saida)
    tempo_total = horario_saida - horario_chegada
    in_system.append(tempo_total)

# Função que define a chegada de clientes
def chegada_dos_clientes(env):
    cliente_id = 0
    while True:
        # Tempo de chegada do próximo cliente, ajustado para considerar horários de pico
        tempo_do_proximo_cliente = distribuicao_chegada_de_clientes(env)
        yield env.timeout(tempo_do_proximo_cliente)

        # Cliente chegou, registra o horário de chegada
        tempo_de_chegada = env.now
        chegadas.append(tempo_de_chegada)
        cliente_id += 1

        # Define se o cliente é preferencial
        preferencial = np.random.rand() < PROBABILIDADE_DE_CLIENTE_PREFERENCIAL
        tipo_cliente = "preferencial" if preferencial else "público-geral"
        print('%3d cliente (%s) chegou no mercado em %.2f' % (cliente_id, tipo_cliente, tempo_de_chegada))

        # Processo de atendimento no caixa
        env.process(atendimento(env, cliente_id, tempo_de_chegada, preferencial))

# Tempo de atendimento do cliente no caixa
def tempo_de_atendimento_cliente():
    return norm.rvs(loc=MEDIA_DO_TEMPO_DE_ATENDIMENTO, scale=DESVIO_PADRAO_DO_TEMPO_DE_ATENDIMENTO)

# Processo de atendimento no caixa, com desistência por excesso de espera e falhas de uso excessivo
def atendimento(env, cliente_id, horario_chegada, preferencial):
    global uso_dos_caixas, falhas_no_sistema
    with (caixas_preferenciais if preferencial else caixas_normais).request(priority=0 if preferencial else 1) as req:
        print('%3d cliente (%s) entrou na fila em %.2f' % (cliente_id, "preferencial" if preferencial else "público-geral", env.now))
        horario_entrada_da_fila = salva_info_da_fila(env, caixas_normais if not preferencial else caixas_preferenciais)

        # Espera até que o caixa esteja disponível ou até o tempo máximo de espera
        resultado = yield req | env.timeout(TEMPO_MAXIMO_DE_ESPERA)

        # Verifica se o cliente conseguiu ser atendido ou desistiu
        if req in resultado:
            # Incrementa o contador de uso do caixa
            uso_dos_caixas += 1

            # Verifica se o caixa falha com base na probabilidade que aumenta com o uso
            probabilidade_de_falha = PROBABILIDADE_BASE_DE_FALHA + (uso_dos_caixas * AUMENTO_PROBABILIDADE_POR_USO)
            if np.random.rand() < probabilidade_de_falha:
                # Falha no caixa
                falhas_no_sistema += 1
                print(f'Falha no sistema! Caixa em reparo no tempo {env.now:.2f}. Total de falhas: {falhas_no_sistema}')
                yield env.timeout(TEMPO_DE_REPARO)
                uso_dos_caixas = 0  # Reseta o contador após o reparo

            # Cliente conseguiu ser atendido
            print('%3d cliente (%s) saiu da fila em %.2f' % (cliente_id, "preferencial" if preferencial else "público-geral", env.now))
            horario_saida_da_fila = salva_info_da_fila(env, caixas_normais if not preferencial else caixas_preferenciais)

            # Tempo que o cliente permaneceu na fila
            tempo_na_fila = horario_saida_da_fila - horario_entrada_da_fila
            in_queue.append(tempo_na_fila)

            # Execução do atendimento no caixa
            tempo_atendimento = tempo_de_atendimento_cliente()
            tempos_de_atendimento.append(tempo_atendimento)  # Registra o tempo de atendimento
            yield env.timeout(tempo_atendimento)
            print('%3d cliente (%s) foi atendido em %.2f' % (cliente_id, "preferencial" if preferencial else "público-geral", tempo_atendimento))

            # Tempo total de permanência no sistema
            calcula_tempo_no_sistema(env, horario_chegada)
        else:
            # Cliente desistiu por tempo de espera excessivo
            print('%3d cliente (%s) desistiu da fila em %.2f' % (cliente_id, "preferencial" if preferencial else "público-geral", env.now))
            desistencias.append(env.now)

# Função para calcular e exibir as métricas globais ao final da simulação
def exibir_metricas_globais():
    total_clientes = len(chegadas)
    total_desistencias = len(desistencias)
    media_tempo_fila = np.mean(in_queue) if in_queue else 0
    media_tempo_sistema = np.mean(in_system) if in_system else 0
    taxa_desistencia = (total_desistencias / total_clientes) * 100 if total_clientes > 0 else 0

    print("\n--- Métricas Globais ---")
    print(f"Total de clientes atendidos: {total_clientes - total_desistencias}")
    print(f"Total de desistências: {total_desistencias}")
    print(f"Taxa de desistência: {taxa_desistencia:.2f}%")
    print(f"Tempo médio na fila: {media_tempo_fila:.2f}")
    print(f"Tempo médio no sistema: {media_tempo_sistema:.2f}")
    print(f"Total de falhas no sistema: {falhas_no_sistema}")

# Configurações da simulação
TEMPO_DE_SIMULACAO = 100
QUANTIDADE_DE_CAIXAS = 3  # Quantidade de caixas normais

# Seed fixa para resultados reprodutíveis
np.random.seed#(1)

# Preparação do ambiente de simulação
env = simpy.Environment()

# Criando os recursos de caixas, com uma fila para preferenciais e outra para normais
caixas_normais = simpy.PriorityResource(env, capacity=QUANTIDADE_DE_CAIXAS)
caixas_preferenciais = simpy.PriorityResource(env, capacity=1)  # Fila exclusiva preferencial

# Inicia o processo de chegada dos clientes
env.process(chegada_dos_clientes(env))

# Executa a simulação
env.run(until=TEMPO_DE_SIMULACAO)

# Exibe as métricas globais ao final da simulação
exibir_metricas_globais()

"""#Gráficos com as entradas e saídas de cada cliente"""

# Gráfico de Entradas e Saídas
plt.figure(figsize=(10, 6))

# Plotando chegadas
plt.plot(chegadas, range(1, len(chegadas) + 1), marker='o', linestyle='-', color='blue', label='Chegadas')
# Plotando saídas
plt.plot(saidas, range(1, len(saidas) + 1), marker='o', linestyle='-', color='red', label='Saídas')

# Configurando o gráfico
plt.title('Fluxo de Entrada e Saída na Fila do Supermercado')
plt.xlabel('Tempo')
plt.ylabel('Número de Clientes')
plt.legend()
plt.grid(True)

# Exibindo o gráfico
plt.show()

"""# Tempo de trabalho do servidor ao longo do tempo"""

# Configuração do tamanho do gráfico
fig, (ax1) = plt.subplots(1)
fig.set_size_inches(20, 8)

# Gráfico 1: Distribuição Gaussiana (Normal) para o tempo de atendimento
media, desvio = 10, 5  # média e desvio padrão
x_gaussiana = np.random.normal(media, desvio, 1000)
ax1.text(media - 10, 80, r'$\mu=' + str(media) + ',\ \sigma=' + str(desvio) + '$')
ax1.hist(x_gaussiana, bins=30, edgecolor="white")
ax1.set_xlabel('Tempo de Atendimento (min)')
ax1.set_ylabel('Ocorrências')
ax1.set_title('Distribuição Gaussiana (Normal)')
ax1.grid()

"""#Tempo que um usuário fica na fila"""

import matplotlib.pyplot as plt

# Gráfico de Tempo de Espera na Fila
plt.figure(figsize=(10, 6))

# Plotando o tempo de espera de cada cliente na fila
plt.plot(range(1, len(in_queue) + 1), in_queue, marker='o', linestyle='-', color='purple', label='Tempo na Fila')

# Configurando o gráfico
plt.title('Tempo de Espera na Fila para Cada Cliente')
plt.xlabel('Cliente')
plt.ylabel('Tempo na Fila')
plt.legend()
plt.grid(True)

# Exibindo o gráfico
plt.show()